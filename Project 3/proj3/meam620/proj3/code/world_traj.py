import numpy as np

from .graph_search import graph_search
from copy import copy

class WorldTraj(object):
    """

    """
    def __init__(self, world, start, goal):
        """
        This is the constructor for the trajectory object. A fresh trajectory
        object will be constructed before each mission. For a world trajectory,
        the input arguments are start and end positions and a world object. You
        are free to choose the path taken in any way you like.

        You should initialize parameters and pre-compute values such as
        polynomial coefficients here.

        Parameters:
            world, World object representing the environment obstacles
            start, xyz position in meters, shape=(3,)
            goal,  xyz position in meters, shape=(3,)

        """

        # You must choose resolution and margin parameters to use for path
        # planning. In the previous project these were provided to you; now you
        # must chose them for yourself. Your may try these default values, but
        # you should experiment with them!
        self.resolution = np.array([0.15, 0.15, 0.15])   # resolution in x,y,z
        self.margin = 0.6      # obstacle expansion

        # You must store the dense path returned from your Dijkstra or AStar
        # graph search algorithm as an object member. You will need it for
        # debugging, it will be used when plotting results.
        self.path, _ = graph_search(world, self.resolution, self.margin, start, goal, astar=True)   # get origin path

        # You must generate a sparse set of sparse_waypoints to fly between. Your
        # original Dijkstra or AStar path probably has too many points that are
        # too close together. Store these sparse_waypoints as a class member; you will
        # need it for debugging and it will be used when plotting results.
        self.points = np.zeros((1,3))      # a sparse set of sparse_waypoints

        # Finally, you must compute a trajectory through the sparse_waypoints similar
        # to your task in the first project. One possibility is to use the
        # WaypointTraj object you already wrote in the first project. However,
        # you probably need to improve it using techniques we have learned this
        # semester.

        # STUDENT CODE HERE
        
        # some tunable parameters：
        self.avg_speed = 3.18   # average linear speed
        self.sparse_interval = 12   # how many interals used to downsample the waypoints (越大越稀疏)

        # down sample waypoints generated by graph search
        self.down_sample_waypoints()

        # segment the path into small segmentations
        self.path_segment()
       
        # size = self.duration.shape[0]
        self.duration[0] = self.duration[0]*2.5
        self.duration[-1] = self.duration[-1]*2.5

        # build up the matrix equation Ax=B in slide 10 page 45
        self.build_equation_matrix()

        # add position constraint to matrix
        self.add_position_constraint()

        # add position constraints to proper positions of the big matrix
        self.add_BC()

        # reset index to add continuity constraints on to the matrix at the proper positions
        self.i = self.i+2
        self.j = 0
        self.k = 0

        flag = True
        
        flag = self.continuity_constraints(flag)

        #computing coefficient matrix using : x = inv(A) x B
        self.coeff_mat = np.linalg.inv(self.left_matrix) @ self.right_matrix

        #segment tracking, flight time and coefficient matrix pointer variables
        self.prev_time = 0
        self.pointer = 0
        self.segment_start_time = 0
        self.coeff_mat_counter = 0
        self.prev_x = np.zeros((3,1))
        
        
    def down_sample_waypoints(self):
        """down sample waypoints generated by graph search
        """
        self.end_point = self.path[-1].reshape((1,3))
        self.sparse_waypoints = np.concatenate((self.path[0:-1:self.sparse_interval], self.end_point), axis = 0)
        self.num_sparse_points = self.sparse_waypoints.shape[0]
        self.points = copy(self.sparse_waypoints)

        
    def path_segment(self):
        """segment the path into small parts according to the result of waypoint downsample
        """
        self.start_points = []
        self.end_points = []
        self.vectors = []
        self.distances = []
        for i in range(self.num_sparse_points-1):
            self.start_points.append(self.sparse_waypoints[i])
            self.end_points.append(self.sparse_waypoints[i+1])
            vector = self.end_points[i] - self.start_points[i]
            distance = np.linalg.norm(vector)
            self.vectors.append(vector / distance)
            self.distances.append(distance)
            
        self.start_points = np.array(self.start_points)
        self.end_points = np.array(self.end_points)
        self.vectors = np.array(self.vectors)
        self.distances = np.array(self.distances)
        self.duration = self.distances/self.avg_speed


    def build_equation_matrix(self):
        """build equation matrix A and B
        """
        self.num_segments = self.vectors.shape[0]
        self.left_matrix = np.zeros((6 * self.num_segments, 6 * self.num_segments))   # A matirx (6n*6n)
        self.right_matrix = np.zeros((6 * self.num_segments, 3))   # B matrix (6n*3)


    def add_position_constraint(self):
        """add position constraints to proper positions of the big matrix
        """
        for segment in range(self.num_segments):
            self.i = segment * 2  # This replaces your i and j management
            self.k = segment * 6  # This directly calculates k without incrementing it inside the loop

            self.right_matrix[self.i] = self.start_points[segment]   # Right side first row = start point of the segment
            self.right_matrix[self.i + 1] = self.end_points[segment]   # Right side second row = end point of the segment

            self.left_matrix[self.i, self.k:self.k+6] = np.array([0, 0, 0, 0, 0, 1])
            self.left_matrix[self.i + 1, self.k:self.k+6] = np.array([self.duration[segment]**5, self.duration[segment]**4, self.duration[segment]**3, self.duration[segment]**2, self.duration[segment], 1])
            
        self.j = self.num_segments - 1
        self.i = self.num_segments * 2
        self.k = self.num_segments * 6
        
        
    def add_BC(self):
        """add velocity and acceleration boundary conditions to the matrix
        """
        # velocity at start of path and end of path 
        self.k = 0
        self.left_matrix[self.i, self.k:self.k+6] = np.array([0,0,0,0,1,0])    # velocity at start point
        self.right_matrix[self.i] = np.array([0,0,0])
        self.k = self.left_matrix.shape[1]-6     # velocity at end point
        self.left_matrix[self.i+1, self.k:self.k+6] = np.array([5*(self.duration[self.j]**4), 4*(self.duration[self.j]**3), 3*(self.duration[self.j]**2), 2*self.duration[self.j], 1, 0])
        self.right_matrix[self.i+1] = np.array([0,0,0])

        self.i = self.i+2
        # acceleration at start of path and end of path 
        self.k=0
        self.left_matrix[self.i, self.k:self.k+6] = np.array([0,0,0,2,0,0])    # acceleration at start point
        self.right_matrix[self.i] = np.array([0,0,0])
        self.k = self.left_matrix.shape[1]-6     #for acceleration at end point
        self.left_matrix[self.i+1, self.k:self.k+6] = np.array([20*(self.duration[self.j]**3), 12*(self.duration[self.j]**2), 6*(self.duration[self.j]), 2, 0, 0])
        self.right_matrix[self.i+1] = np.array([0,0,0])
        
    
    def continuity_constraints(self, flag):
        """add continuity constraints on to the matrix at the proper positions
        """

        # continuity constraints on the derivatives of the 5th order polynomial of minimum jerk trajectory
        while flag:
            
            # velocity continuity
            self.left_matrix[self.i, self.k:self.k+12] = np.array([5*(self.duration[self.j]**4), 4*(self.duration[self.j]**3), 3*(self.duration[self.j]**2), 2*self.duration[self.j], 1, 0, 0,0,0,0,-1,0])
            self.right_matrix[self.i] = np.array([0,0,0])

            # acceleration continuity
            self.left_matrix[self.i+1, self.k:self.k+12] = np.array([20*(self.duration[self.j]**3), 12*(self.duration[self.j]**2), 6*(self.duration[self.j]), 2, 0, 0, 0,0,0,-2,0,0])
            self.right_matrix[self.i+1] = np.array([0,0,0])

            # jerk continuity
            self.left_matrix[self.i+2, self.k:self.k+12] = np.array([60*(self.duration[self.j]**2), 24*(self.duration[self.j]), 6, 0, 0, 0, 0,0,-6,0,0,0])
            self.right_matrix[self.i+2] = np.array([0,0,0])

            # snap continuitiy
            self.left_matrix[self.i+3, self.k:self.k+12] = np.array([120*(self.duration[self.j]), 24, 0, 0, 0, 0, 0,-24,0,0,0,0])
            self.right_matrix[self.i+3] = np.array([0,0,0])

            self.i = self.i+4
            self.j = self.j+1
            self.k = self.k+6
            
            print(self.i,self.j,self.k)

            #end loop when all intermediate sparse_waypoints are covered
            if(self.j == self.num_segments-1):
                flag = False

        return flag


    def update(self, t):
        """
        Given the present time, return the desired flat output and derivatives.

        Inputs
            t, time, s
        Outputs
            flat_output, a dict describing the present desired flat outputs with keys
                x,        position, m
                x_dot,    velocity, m/s
                x_ddot,   acceleration, m/s**2
                x_dddot,  jerk, m/s**3
                x_ddddot, snap, m/s**4
                yaw,      yaw angle, rad
                yaw_dot,  yaw rate, rad/s
        """
        flat_output = {}
        x        = np.zeros((3,))
        x_dot    = np.zeros((3,))
        x_ddot   = np.zeros((3,))
        x_dddot  = np.zeros((3,))
        x_ddddot = np.zeros((3,))
        yaw = 0
        yaw_dot = 0

        # STUDENT CODE HERE

        # Checking if quad is within the current segment duration
        if t < np.sum(self.duration[:self.pointer+1]):
            del_t = t - self.segment_start_time  # computing delta_t

            # Define matrices for computing derivatives
            derivatives = [
                np.array([[del_t**5, del_t**4, del_t**3, del_t**2, del_t, 1]]),
                np.array([[5*(del_t**4), 4*(del_t**3), 3*(del_t**2), 2*del_t, 1, 0]]),
                np.array([[20*(del_t**3), 12*(del_t**2), 6*del_t, 2, 0, 0]]),
                np.array([[60*(del_t**2), 24*del_t, 6, 0, 0, 0]]),
                np.array([[120*del_t, 24, 0, 0, 0, 0]])
            ]

            # Compute position, velocity, acceleration, jerk, and snap
            states = [x, x_dot, x_ddot, x_dddot, x_ddddot]
            for state, derivative in zip(states, derivatives):
                state[:] = derivative @ self.coeff_mat[self.coeff_mat_counter:self.coeff_mat_counter+6]
                state = state.reshape((3,))

            self.prev_x = x
            self.prev_time = t

        elif t >= np.sum(self.duration[:self.pointer+1]) and t < np.sum(self.duration[:self.pointer+2]):
            self.pointer += 1  # Move to the next segment
            self.segment_start_time = self.prev_time
            self.coeff_mat_counter += 6  # Update coefficients to the new segment
            if self.pointer == self.end_points.shape[0]:
                # Make the bot hover at the endpoint after all segments are completed
                x = self.sparse_waypoints[-1,:].copy()
                x_dot = x_ddot = np.zeros((3,))
            else:
                # Assign values for the new segment start
                x = self.sparse_waypoints[self.pointer,:].copy()
                del_t = t - np.sum(self.duration[:self.pointer+1])  # Delta time for new segment start

                # Recompute derivatives for the new segment start
                derivatives = [
                    np.array([[5*(del_t**4), 4*(del_t**3), 3*(del_t**2), 2*del_t, 1, 0]]),
                    np.array([[20*(del_t**3), 12*(del_t**2), 6*del_t, 2, 0, 0]]),
                    np.array([[60*(del_t**2), 24*del_t, 6, 0, 0, 0]]),
                    np.array([[120*del_t, 24, 0, 0, 0, 0]])
                ]

                for state, derivative in zip([x_dot, x_ddot, x_dddot, x_ddddot], derivatives):
                    state[:] = derivative @ self.coeff_mat[self.coeff_mat_counter:self.coeff_mat_counter+6]
                    state = state.reshape((3,))

        else:
            # Hover at the last point if all segments are complete
            x = self.sparse_waypoints[-1,:].copy()

        # flat output
        flat_output['x'] = x
        flat_output['x_dot'] = x_dot
        flat_output['x_ddot'] = x_ddot
        flat_output['x_dddot'] = x_dddot
        flat_output['x_ddddot'] = x_ddddot
        flat_output['yaw'] = yaw
        flat_output['yaw_dot'] = yaw_dot
        
        return flat_output